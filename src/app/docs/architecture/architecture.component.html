<div class="container">
    <!-- For search -->
    <span class="anchor"
        keywords="apirtc,application,backend,client,paas,platform,portal,hook,webhooks,restful,sfu,signaling,stun,turn,storage,users,management">
    </span>
    <!-- For search -->
    <div class="row justify-content-center">
        <div class="col-10 fs-5">
            <p class="text-center">
                Any <strong>ApiRTC</strong> solution involves at least two software parts: the <strong>Client
                    Application</strong> and
                <strong>ApiRTC PaaS Platform</strong>.
            </p>
        </div>
    </div>
    <div class="row mt-5 align-items-center">
        <div class="col">
            <img src="./assets/apirtc-architecture.svg"
                alt="Architecture schema (refresh page if schema does not appear)" class="img-fluid" width="856"
                height="662" />
        </div>
        <div class="col-md-12 col-lg-4">
            <div class="row">
                <div class="col">
                    <h1>
                        Client Application
                    </h1>
                    <p>
                        The client application is the web or mobile application that connects users together. It allows
                        them to
                        share messages or media, and it displays messages or media from the others.
                    </p>
                    <p> <strong>ApiRTC</strong> let's you build web and mobile applications, using any modern
                        application
                        framework or native languages.</p>
                </div>
            </div>
            <div class="row mt-5">
                <h1>
                    Application Backend
                </h1>
                <div class="col">
                    <p>The application backend may require some interactions with <strong>ApiRTC Platform</strong>.</p>
                </div>
            </div>
        </div>
    </div>
    <div class="row mt-3">
        <h1>
            ApiRTC PaaS Platform
        </h1>
        <div class="col-lg-10">
            <!-- <p>
        The <strong>ApiRTC</strong> platform is involved at least as a signaling server. Depending on
        the User Management it can also act as an authentication server.
    </p> -->
            <p>The <strong>ApiRTC</strong> platform is compound of different systems. All together they bring a
                full
                featured communication system for various applications.</p>
        </div>
    </div>
    <hr class="my-5">
    <h2 class="text-center">
        More details
    </h2>
    <div class="row mt-5">
        <div class="col align-self-center">
            <div class="row justify-content-center">
                <div class="col-7">
                    <p class="text-center">
                        <img src="./assets/sfus.svg" alt="SFUs" class="img-fluid" width="168" height="129" />
                    </p>
                </div>
            </div>
        </div>
        <div class="col-lg-9">
            <p>
                <strong>ApiRTC</strong> features <strong>SFUs</strong> servers to enable large number of users video
                conferences to happen
            </p>
            <p>
                Tell about peer-to-peer, mesh mode, star topolofy SFUs... :
            </p>
            <p>
                Basic <strong>WebRTC</strong> applications are using full mesh topology. Each client must :
            </p>
            <ul>
                <li>
                    encode and send their stream(s) to each remote peer
                </li>
                <li>
                    receive and decode every remote peer stream(s)
                </li>
            </ul>
            <p>
                The CPU load and the required bandwidth increases linearly as the number of peers and streams
                grows. This topology is unsuitable for applications where larger groups of peers need to be
                connected at once.
            </p>
            <p>
                <strong>ApiRTC</strong> enables the usage of a <strong>star topology</strong> by providing SFUs
                (Selective Forwarding Units) that acts as a central server that relays each peers’ streams.
            </p>
            <!-- <p>
                MCU (stands for Multipoint Control Unit) can also be used (TODO: check this ?)
            </p> -->
            <p>
                In <strong>ApiRTC</strong>, media streams flow through <strong>ApiRTC</strong> infrastructure SFUs.
            </p>
            <p>
                But you can control that my enabling meshMode, and event force it remain mesh. Otherwise
                <strong>ApiRTC</strong> will
                automatically try to switch to star topology architecture.
            </p>
        </div>
    </div>
    <div class="row  mt-5 justify-content-end align-items-center">
        <div class="col-9">
            <!-- <h3>Signaling</h3> -->
            <p>
                In order to realize a <strong>WebRTC</strong> application, one must establish a connection
                between the browsers that want to communicate. <strong>WebRTC</strong> provides the solution
                for
                the media plane but does not implement the signaling, i.e. how one client’s information
                should be sent to remote peers in order to initiate connections.
                <strong>ApiRTC CCS</strong> implements a signaling server using WebSockets. The browser
                and
                server interaction is event-based : the browser does not have to poll the server for a reply
                every time data have to be exchanged.
            </p>
            <!-- <p>TODO : PARTICIPATION ?</p>
            <p>presence, signaling, and routing</p> -->
        </div>
        <div class="col align-self-center">
            <div class="row justify-content-center">
                <div class="col-9">
                    <p class="text-center">
                        <img src="./assets/signaling-system.svg" alt="Signaling-System" class="img-fluid" width="223"
                            height="57" />
                    </p>
                </div>
            </div>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col align-self-center">
            <div class="row justify-content-center">
                <div class="col-9">
                    <p class="text-center">
                        <img src="./assets/storage.svg" alt="Storage" class="img-fluid" width="223" height="87" />
                    </p>
                </div>
            </div>
        </div>
        <div class="col-9">
            <h3>Users management</h3>
            <p>
                When it comes to <strong>Users management</strong>, one can decide to use his own or leverage with
                <strong>ApiRTC</strong>'s.
            </p>
            <h3>Media storage</h3>
            <p>
                <strong>ApiRTC</strong> also includes databases for <strong>Media storage</strong>, providing a
                secure way to store exchanged data or conversations recordings.
            </p>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col-9">
            <p> To send and receive data to another browser the client must have some specific information. The
                most important information is the client’s public IP address. Each client or browser must know
                this information about each other in order
                to receive an incoming connection from another client.</p>

            <p>Sometimes, users might face connectivity issues because of different IP networks where Firewalls and
                NATs
                (Network Address Translators) could include specific network policies that will not allow RTC
                communications.</p>
            <!-- <p>
                    Sometimes it’s difficult for the client
                    to know its own public IP address, especially if the client is behind a firewall or NAT, which
                    is very common these days. 
                </p> -->
            <p>To overcome
                this, <strong>WebRTC</strong> recommends the use of a STUN server. A STUN server allows clients
                to find out their own public IP address and which type of NAT they are behind. Sometimes it can
                be hard to fetch the information, depending on the NAT,
                and in that case, a TURN server can help the process.</p>
            <p>In order to solve this kind of network connection scenario, we need to use ICE (Interactive
                Connectivity
                Establishment) protocol and it defines a systematic way of finding possible communication options
                between a peer and the video gateway.</p>
            <ul>
                <li>
                    <p>ICE (INTERACTIVE CONNECTIVITY ESTABLISHMENT) is a protocol used to generate media traversal
                        candidates
                        that can be used in WebRTC applications, and it can be successfully sent and received through
                        Network
                        Address Translation (NAT)s using STUN and TURN.</p>
                </li>
                <li>
                    <p>STUN (Session Traversal Utilities for NAT) that complements ICE through NATs using UDP protocol.
                        STUN
                        allows applications to discover the presence and types of NATs and firewalls between them and on
                        the
                        public Internet. It can be used by any device to determine the IP address and port allocated to
                        it
                        by a NAT.</p>
                    <p>Typically A STUN client can send messages to the STUN server to get the Public IP and ports
                        information
                        then STUN server retrieve that information. Using this Public IP and Port information clients
                        will
                        make
                        a peer to peer communication through the internet.</p>
                </li>
                <li>
                    <p>TURN (Traversal Using Relays around NAT) is a protocol that assists in the traversal of network
                        address translators (NAT) or firewalls for webRTC applications. TURN Server allows clients to
                        send and receive data through an intermediary server. The TURN protocol is the extension to
                        STUN.</p>
                </li>
            </ul>
            <p>In a few cases, client communication endpoints are stuck behind different types of NATs, or when a
                symmetric NAT is in use, it may be easier to send media through a relay server and its called the
                TURN server.</p>
            <p><strong>ApiRTC</strong> provides both STUN and TURN servers to address theses WebRTC requirements.
            </p>
        </div>
        <div class="col align-self-center">
            <p class="text-center">
                <img src="./assets/stun-turn.svg" alt="STUN-TURN" class="img-fluid" width="130" height="127" />
            </p>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col align-self-center">
            <p class="text-center">
                <img src="./assets/web-portal.svg" alt="web-portal" class="img-fluid" width="106" height="106" />
            </p>
        </div>
        <div class="col-9">
            <p>
                <strong>ApiRTC Dashboard</strong> is the portal to access your account on <strong>ApiRTC
                    platform</strong>.
            </p>
            <p>
                It gives you access to the configuration of your Enterprise(s), Users and services.
            </p>
            <!-- <p>TODO : PARTICIPATION ?</p>

            <h3>Billing Consumption?</h3>
            <p>stats</p>

            <h3>Configuration</h3>
            <p>auth, and ??</p> -->
        </div>
    </div>
</div>