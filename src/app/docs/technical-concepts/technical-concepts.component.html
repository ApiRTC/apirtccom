<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-10 fs-5">
            <p class="text-center">
                Any <strong>ApiRTC</strong> solution involves at least two software parts: the <strong>Client
                    Application</strong> and
                <strong>ApiRTC PaaS Platform</strong>.
            </p>
        </div>
    </div>
    <div class="row mt-5">
        <div class="col">
            <h1>
                Client Application
            </h1>
            <p>
                The client application is the web or mobile application that connects users together. It allows them to
                share messages or media, and it displays messages or media from the others.
            </p>
            <p> <strong>ApiRTC</strong> let's you build web and mobile applications, using any modern application
                framework or native languages.</p>
        </div>
    </div>
    <div class="row mt-5">
        <h1>
            ApiRTC Platform
        </h1>
        <div class="col-lg-6">
            <!-- <p>
                The <strong>ApiRTC</strong> platform is involved at least as a signalisation server. Depending on
                the User Management it can also act as an authentication server.
            </p> -->
            <p>The <strong>ApiRTC</strong> platform is compound of different systems. All together they bring a full
                featured communication system for various applications.</p>
        </div>
    </div>
    <div class="row mt-5">
        <h2>
            ApiRTC CCS
        </h2>
        <p><strong>CCS</strong> stands for <strong>C</strong>all <strong>C</strong>ontrol <strong>S</strong>erver.
            <strong>CCS</strong> is responsible for <strong>signalisation</strong> and TODO
        </p>
    </div>
    <div class="row mt-5 justify-content-end">
        <div class="col-lg-8">
            <h3>Signalisation</h3>
            <p class="col-lg-8">
                In order to realize a <strong>WebRTC</strong> application, one must establish a connection
                between the browsers that want to communicate. <strong>WebRTC</strong> provides the solution
                for
                the media plane but does not implement the signaling, i.e. how one client’s information
                should be sent to remote peers in order to initiate connections.
                <strong>ApiRTC cloud</strong> implements a signaling server using WebSockets. The browser
                and
                server interaction is event-based : the browser does not have to poll the server for a reply
                every time data have to be exchanged.
            </p>
            <p>TODO : PARTICIPATION ?</p>
        </div>
    </div>
    <div class="row mt-5 justify-content-start">
        <div class="col-lg-8">
            <h2>
                ApiRTC Cloud
            </h2>
            <p>
                <strong>ApiRTC Cloud</strong> hosts the configuration of your Enterprise(s) and services.
            </p>
            <h3>Users management</h3>
            <p>
                When it comes to <strong>Users management</strong>, one can decide to use his own or leverage with
                <strong>ApiRTC</strong>'s.
            </p>
            <h3>Media storage</h3>
            <p>
                <strong>ApiRTC</strong> also includes databases for <strong>Media storage</strong>, providing a
                secure way to store exchanged data or conversations recordings.
            </p>
            <p>TODO : PARTICIPATION ?</p>
        </div>
    </div>
    <div class="row mt-5 justify-content-end">
        <div class="col-lg-8">
            <h2>
                ApiRTC STUN/TURN
            </h2>
            <p> To send and receive data to another browser the client must have some specific information. The
                most important information is the client’s public IP address. Each client or browser must know
                this information about each other in order
                to receive an incoming connection from another client.</p>

            <p>Sometimes, users might face connectivity issues because of different IP networks where Firewalls and
                NATs
                (Network Address Translators) could include specific network policies that will not allow RTC
                communications.</p>
            <!-- <p>
                    Sometimes it’s difficult for the client
                    to know its own public IP address, especially if the client is behind a firewall or NAT, which
                    is very common these days. 
                </p> -->
            <p>To overcome
                this, <strong>WebRTC</strong> recommends the use of a STUN server. A STUN server allows clients
                to find out their own public IP address and which type of NAT they are behind. Sometimes it can
                be hard to fetch the information, depending on the NAT,
                and in that case, a TURN server can help the process.</p>
            <p>In order to solve this kind of network connection scenario, we need to use ICE (Interactive
                Connectivity
                Establishment) protocol and it defines a systematic way of finding possible communication options
                between a peer and the video gateway.</p>
            <p>ICE (INTERACTIVE CONNECTIVITY ESTABLISHMENT) is a protocol used to generate media traversal
                candidates
                that can be used in WebRTC applications, and it can be successfully sent and received through
                Network
                Address Translation (NAT)s using STUN and TURN.</p>
            <p>STUN (Session Traversal Utilities for NAT) that complements ICE through NATs using UDP protocol. STUN
                allows applications to discover the presence and types of NATs and firewalls between them and on the
                public Internet. It can be used by any device to determine the IP address and port allocated to it
                by a
                NAT.</p>
            <p>Typically A STUN client can send messages to the STUN server to get the Public IP and ports
                information
                then STUN server retrieve that information. Using this Public IP and Port information clients will
                make
                a peer to peer communication through the internet.</p>
            <p>TURN (Traversal Using Relays around NAT) is a protocol that assists in the traversal of network
                address
                translators (NAT) or firewalls for webRTC applications. TURN Server allows clients to send and
                receive
                data through an intermediary server. The TURN protocol is the extension to STUN.</p>
            <p>In a few cases, client communication endpoints are stuck behind different types of NATs, or when a
                symmetric NAT is in use, it may be easier to send media through a relay server and its called the
                TURN
                server.</p>
            <p><strong>ApiRTC</strong> provides both STUN and TURN servers to address theses WebRTC requirements.
            </p>
        </div>
    </div>
    <div class="row mt-5 justify-content-start">
        <div class="col-lg-8">
            <h2>
                ApiRTC SFUs
            </h2>
            <p>
                ApiRTC features SFUs servers to enable large number of users video conferences to happen
            </p>
            <p>
                Tell about peer-to-peer, mesh mode, star topolofy SFUs... :
            </p>
            <p>
                Basic <strong>WebRTC</strong> applications are using full mesh topology. Each client must :
            </p>
            <ul>
                <li>
                    encode and send their stream(s) to each remote peer
                </li>
                <li>
                    receive and decode every remote peer stream(s)
                </li>
            </ul>
            <p>
                The CPU load and the required bandwidth increases linearly as the number of peers and streams
                grows. This topology is unsuitable for applications where larger groups of peers need to be
                connected at once.
            </p>
            <p>
                <strong>ApiRTC</strong> enables the usage of a <strong>star topology</strong> by providing SFUs
                (Selective Forwarding Units) that acts as a central server that relays each peers’ streams.
            </p>
            <!-- <p>
                MCU (stands for Multipoint Control Unit) can also be used (TODO: check this ?)
            </p> -->
            <p>
                In ApiRTC, media streams flow through ApiRTC infrastructure SFUs.
            </p>
            <p>
                But you can control that my enabling meshMode, and event force it remain mesh. Otherwise ApiRTC will
                automatically try to switch to star topology architecture.
            </p>
        </div>
    </div>
</div>